---
title: Permissions Admin Flow
description: How administrators manage plans, roles, actions, and permission matrices
---

## Overview

The permissions admin flow lets platform admins configure product plans, define roles, register granular actions, and map which roles can perform which actions per plan. These operations are executed through server actions under `actions/permissions/` and persist data via permissions repositories. Admin access is enforced using `canAccessAdminPages()`, ensuring only project owners/admins (or developers in local environments) can mutate billing metadata.

**Main Libraries/Services:**

- **actions/permissions/actions.ts** – CRUD for action definitions (slug, description, category).
- **actions/permissions/roles.ts** – CRUD for application roles (name, description, hierarchy).
- **actions/permissions/plans.ts** – CRUD for subscription plans (name, slug, price metadata, limits).
- **actions/permissions/permissions.ts** – Upserts role-action permissions for a given plan.
- **services/permissions/permission-service.ts** – Runtime permission checks (consumes admin-managed data).
- **services/permissions/cache-service.ts** – Invalidates caches when plan/role/action data changes.
- **lib/permissions/admin-access.ts** – Central guard to confirm admin privileges before executing actions.
- **repositories/permissions/** – Kysely SQL helpers for plans, roles, actions, permissions, and caches.

## File Map

- `actions/permissions/index.ts` – Barrel export for all admin actions.
- `actions/permissions/actions.ts` – `getActions`, `createActionAction`, `updateActionAction`, `deleteActionAction`.
- `actions/permissions/roles.ts` – `getRoles`, `createRoleAction`, `updateRoleAction`, `deleteRoleAction`.
- `actions/permissions/plans.ts` – `getPlans`, `createPlanAction`, `updatePlanAction`.
- `actions/permissions/permissions.ts` – `getPermissions`, `updatePermissionAction`.
- `services/permissions/permission-service.ts` – Reads cached permission rules to answer runtime checks.
- `services/permissions/cache-service.ts` – Exposes `clearAll`, `clearForPlan`, `clearForRole`, `clearForAction`, `getStats`.
- `repositories/permissions/{actions,plans,roles,permissions}.ts` – Low-level CRUD and cache utilities.
- `app/(protected)/dashboard/admin/*` – UI that invokes these server actions (plan/role editors, permission matrices).

## Step-by-Step Flow

### Plan/Role/Action Management

1. Admin UI calls server actions (e.g., `createPlanAction`) via form submissions or API routes.
2. Each action verifies session (`getCurrentUser`) and admin privileges (`canAccessAdminPages`), redirecting to `/login` or throwing `Forbidden`.
3. Repository functions execute Kysely queries (with sanitized SQL aliases per standards) to insert/update/delete plans, roles, or actions.
4. After mutations, the UI may call `cacheService` methods to invalidate permission caches for affected plans/roles.
5. Updated lists are returned to the UI for immediate feedback.

### Permission Matrix Updates

1. Admin selects a plan and role in the UI, triggering `getPermissions(planId, roleId?)` to fetch current role-action mapping.
2. The UI toggles permissions and submits payloads to `updatePermissionAction({ planId, roleId, actionId, allowed })`.
3. Server action validates admin privileges, then calls `upsertRoleActionPermission` to insert/update the mapping.
4. Cache invalidation (via `cacheService.clearForPlan(planId)` or `clearForRole(roleId)`) ensures runtime checks pick up the change.
5. `permissionService.canUserPerformAction` now reflects the new rule.

### Runtime Permission Check (Context)

1. At runtime, features call `permissionService.canUserPerformAction(userId, projectId, actionSlug)`.
2. Service loads project plan, user role, and uses cached permission rules.
3. If the admin recently updated permissions, caches have been invalidated to return fresh results.

## Data Flow Diagram

```mermaid
flowchart TD
  A[Admin UI] --> B[Server Action (actions/plans/roles/permissions)]
  B --> C[getCurrentUser()]
  C -->|unauthenticated| D[redirect /login]
  C -->|authenticated| E[canAccessAdminPages()]
  E -->|false| F[Forbidden error]
  E -->|true| G[Repository mutation]
  G --> H[(PostgreSQL)]
  G --> I[cacheService.clear*]
  H --> J[Updated config returned to UI]
  I --> K[permissionService cache refreshed]
  K --> L[Runtime checks honor new rules]
```

## Dependencies & Contracts

- `getActions()/getPlans()/getRoles()` – Return lists for admin UI tables.
- `createActionAction(data)` / `createPlanAction(data)` / `createRoleAction(data)` – Insert new entities; data must follow repository interface contracts.
- `updateActionAction(id, data)` / `updatePlanAction(id, data)` / `updateRoleAction(id, data)` – Update existing records; throw on errors.
- `deleteActionAction(id)` / `deleteRoleAction(id)` – Remove entities; must consider cascade impacts (e.g., removing a role invalidates permissions).
- `getPermissions(planId, roleId?)` – Return matrix of actions with allowed flags.
- `updatePermissionAction(data)` – Upsert a single role-action permission for a plan.
- `cacheService` – Should be called after updates: `clearForPlan`, `clearForRole`, or `clearForAction`.
- `permissionService` – Relies on the persisted data; no direct writes occur here.

## Known Limitations

- There is no batching API for permission updates; toggling many actions triggers multiple requests (potential performance issue).
- Deleting roles or actions may leave orphaned records if not handled by cascading in the database; ensure referential integrity is enforced.
- Admin actions return generic error messages; UI must handle them gracefully.
- No auditing/logging of who changed plans/roles/actions; support troubleshooting may be difficult.
- The UI depends on server action errors to detect unauthorized access; there is no dedicated 403 page yet.

## Notes & TODOs

- Introduce bulk permission update endpoints to reduce network chatter for large matrices.
- Add audit logging (who changed what and when) for compliance and debugging.
- Provide cascade-aware deletion flows with confirmation that highlight impacted permissions.
- Implement optimistic UI with rollback for action toggles.
- Consider rate limiting or throttling admin mutations to prevent accidental overload.
